<?php

declare(strict_types=1);

namespace OffloadProject\Mandate\Commands;

use Exception;
use Illuminate\Console\Command;
use Illuminate\Support\Collection;
use Illuminate\Support\Str;
use OffloadProject\Mandate\CodeFirst\CapabilityDefinition;
use OffloadProject\Mandate\CodeFirst\DefinitionDiscoverer;
use OffloadProject\Mandate\CodeFirst\PermissionDefinition;
use OffloadProject\Mandate\CodeFirst\RoleDefinition;
use Symfony\Component\Console\Attribute\AsCommand;

/**
 * Generate TypeScript types from permissions, roles, and capabilities.
 *
 * Supports both code-first definitions and database records.
 */
#[AsCommand(name: 'mandate:typescript')]
final class TypeScriptCommand extends Command
{
    protected $signature = 'mandate:typescript
                            {--output= : Output file path}
                            {--permissions : Include only permissions}
                            {--roles : Include only roles}
                            {--capabilities : Include only capabilities}';

    protected $description = 'Generate TypeScript types from permissions, roles, and capabilities';

    public function handle(DefinitionDiscoverer $discoverer): int
    {
        /** @var string $output */
        $output = $this->option('output') ?? config('mandate.code_first.typescript_path', resource_path('js/types/mandate.ts'));
        $includeAll = ! $this->option('permissions') && ! $this->option('roles') && ! $this->option('capabilities');

        $includePermissions = $includeAll || $this->option('permissions');
        $includeRoles = $includeAll || $this->option('roles');
        $includeCapabilities = ($includeAll || $this->option('capabilities')) && config('mandate.capabilities.enabled', false);

        $typescript = $this->generateTypeScript(
            $discoverer,
            $includePermissions,
            $includeRoles,
            $includeCapabilities
        );

        // Ensure directory exists
        $directory = dirname($output);
        if (! is_dir($directory)) {
            mkdir($directory, 0755, true);
        }

        file_put_contents($output, $typescript);

        $this->components->info("TypeScript types generated at: {$output}");

        return self::SUCCESS;
    }

    private function generateTypeScript(
        DefinitionDiscoverer $discoverer,
        bool $includePermissions,
        bool $includeRoles,
        bool $includeCapabilities
    ): string {
        $lines = [
            '// Auto-generated by Laravel Mandate - do not edit manually',
            '// Generated at: '.now()->toIso8601String(),
            '',
        ];

        $permissionGroups = [];
        $roleGroups = [];
        $capabilityGroups = [];

        if ($includePermissions) {
            $permissionGroups = $this->collectPermissions($discoverer);

            foreach ($permissionGroups as $groupName => $items) {
                $lines[] = $this->generateConstObject($groupName, $items);
                $lines[] = '';
            }
        }

        if ($includeRoles) {
            $roleGroups = $this->collectRoles($discoverer);

            foreach ($roleGroups as $groupName => $items) {
                $lines[] = $this->generateConstObject($groupName, $items);
                $lines[] = '';
            }
        }

        if ($includeCapabilities) {
            $capabilityGroups = $this->collectCapabilities($discoverer);

            foreach ($capabilityGroups as $groupName => $items) {
                $lines[] = $this->generateConstObject($groupName, $items);
                $lines[] = '';
            }
        }

        // Generate union types
        if (! empty($permissionGroups)) {
            $lines[] = $this->generateUnionType('Permission', array_keys($permissionGroups));
            $lines[] = '';
        }

        if (! empty($roleGroups)) {
            $lines[] = $this->generateUnionType('Role', array_keys($roleGroups));
            $lines[] = '';
        }

        if (! empty($capabilityGroups)) {
            $lines[] = $this->generateUnionType('Capability', array_keys($capabilityGroups));
            $lines[] = '';
        }

        return implode("\n", $lines);
    }

    /**
     * Collect permissions from code-first definitions and database.
     *
     * @return array<string, array<string, string>>
     */
    private function collectPermissions(DefinitionDiscoverer $discoverer): array
    {
        $groups = [];
        $seen = [];

        // Code-first definitions (if enabled)
        if (config('mandate.code_first.enabled', false)) {
            $paths = config('mandate.code_first.paths.permissions', []);
            $paths = is_array($paths) ? $paths : [$paths];
            $definitions = $discoverer->discoverPermissions($paths);

            foreach ($this->groupBySourceClass($definitions) as $className => $items) {
                foreach ($items as $definition) {
                    /** @var PermissionDefinition $definition */
                    $groups[$className][$definition->sourceConstant] = $definition->name;
                    $seen[$definition->name] = true;
                }
            }
        }

        // Database records
        /** @var class-string<\OffloadProject\Mandate\Models\Permission> $permissionClass */
        $permissionClass = config('mandate.models.permission', \OffloadProject\Mandate\Models\Permission::class);

        if (class_exists($permissionClass)) {
            try {
                $dbPermissions = $permissionClass::all();

                foreach ($dbPermissions as $permission) {
                    $name = $permission->name;

                    // Skip if already defined in code-first
                    if (isset($seen[$name])) {
                        continue;
                    }

                    [$groupName, $constName] = $this->parseNameToGroupAndConst($name, 'Permissions');
                    $groups[$groupName][$constName] = $name;
                }
            } catch (Exception) {
                // Database not available or table doesn't exist - skip silently
            }
        }

        // Sort groups and their contents
        ksort($groups);
        foreach ($groups as &$items) {
            ksort($items);
        }

        return $groups;
    }

    /**
     * Collect roles from code-first definitions and database.
     *
     * @return array<string, array<string, string>>
     */
    private function collectRoles(DefinitionDiscoverer $discoverer): array
    {
        $groups = [];
        $seen = [];

        // Code-first definitions (if enabled)
        if (config('mandate.code_first.enabled', false)) {
            $paths = config('mandate.code_first.paths.roles', []);
            $paths = is_array($paths) ? $paths : [$paths];
            $definitions = $discoverer->discoverRoles($paths);

            foreach ($this->groupBySourceClass($definitions) as $className => $items) {
                foreach ($items as $definition) {
                    /** @var RoleDefinition $definition */
                    $groups[$className][$definition->sourceConstant] = $definition->name;
                    $seen[$definition->name] = true;
                }
            }
        }

        // Database records
        /** @var class-string<\OffloadProject\Mandate\Models\Role> $roleClass */
        $roleClass = config('mandate.models.role', \OffloadProject\Mandate\Models\Role::class);

        if (class_exists($roleClass)) {
            try {
                $dbRoles = $roleClass::all();

                foreach ($dbRoles as $role) {
                    $name = $role->name;

                    // Skip if already defined in code-first
                    if (isset($seen[$name])) {
                        continue;
                    }

                    [$groupName, $constName] = $this->parseNameToGroupAndConst($name, 'Roles');
                    $groups[$groupName][$constName] = $name;
                }
            } catch (Exception) {
                // Database not available or table doesn't exist - skip silently
            }
        }

        // Sort groups and their contents
        ksort($groups);
        foreach ($groups as &$items) {
            ksort($items);
        }

        return $groups;
    }

    /**
     * Collect capabilities from code-first definitions and database.
     *
     * @return array<string, array<string, string>>
     */
    private function collectCapabilities(DefinitionDiscoverer $discoverer): array
    {
        $groups = [];
        $seen = [];

        // Code-first definitions (if enabled)
        if (config('mandate.code_first.enabled', false)) {
            $paths = config('mandate.code_first.paths.capabilities', []);
            $paths = is_array($paths) ? $paths : [$paths];
            $definitions = $discoverer->discoverCapabilities($paths);

            foreach ($this->groupBySourceClass($definitions) as $className => $items) {
                foreach ($items as $definition) {
                    /** @var CapabilityDefinition $definition */
                    $groups[$className][$definition->sourceConstant] = $definition->name;
                    $seen[$definition->name] = true;
                }
            }
        }

        // Database records
        /** @var class-string<\OffloadProject\Mandate\Models\Capability> $capabilityClass */
        $capabilityClass = config('mandate.models.capability', \OffloadProject\Mandate\Models\Capability::class);

        if (class_exists($capabilityClass)) {
            try {
                $dbCapabilities = $capabilityClass::all();

                foreach ($dbCapabilities as $capability) {
                    $name = $capability->name;

                    // Skip if already defined in code-first
                    if (isset($seen[$name])) {
                        continue;
                    }

                    [$groupName, $constName] = $this->parseNameToGroupAndConst($name, 'Capabilities');
                    $groups[$groupName][$constName] = $name;
                }
            } catch (Exception) {
                // Database not available or table doesn't exist - skip silently
            }
        }

        // Sort groups and their contents
        ksort($groups);
        foreach ($groups as &$items) {
            ksort($items);
        }

        return $groups;
    }

    /**
     * Parse a name like "article:view" into group name and constant name.
     *
     * Examples:
     * - "article:view" → ["ArticlePermissions", "VIEW"]
     * - "user.create" → ["UserPermissions", "CREATE"]
     * - "admin" → ["Roles", "ADMIN"]
     * - "article:*" → ["ArticlePermissions", "WILDCARD"]
     * - "*" → ["Permissions", "WILDCARD"]
     *
     * @return array{0: string, 1: string}
     */
    private function parseNameToGroupAndConst(string $name, string $defaultGroup): array
    {
        // Check for prefix:action or prefix.action pattern
        if (preg_match('/^([a-zA-Z][a-zA-Z0-9_-]*)[:.](.+)$/', $name, $matches)) {
            $prefix = $matches[1];
            $action = $matches[2];

            // Convert prefix to PascalCase and append type suffix
            $groupName = Str::studly($prefix).$defaultGroup;

            // Convert action to UPPER_SNAKE_CASE
            $constName = $this->sanitizeConstName(Str::upper(Str::snake($action)));

            return [$groupName, $constName];
        }

        // No prefix - use default group
        $constName = $this->sanitizeConstName(Str::upper(Str::snake($name)));

        return [$defaultGroup, $constName];
    }

    /**
     * Sanitize a constant name to be a valid TypeScript identifier.
     *
     * Replaces wildcards and other invalid characters with valid alternatives.
     */
    private function sanitizeConstName(string $name): string
    {
        // Replace standalone wildcard or wildcard portions
        $name = str_replace('*', 'WILDCARD', $name);

        // Replace any remaining characters that aren't valid in identifiers
        $name = (string) preg_replace('/[^A-Z0-9_]/', '_', $name);

        // Ensure it doesn't start with a digit
        if ($name !== '' && ctype_digit($name[0])) {
            $name = '_'.$name;
        }

        return $name === '' ? 'UNKNOWN' : $name;
    }

    /**
     * Group definitions by their source class.
     *
     * @template T of PermissionDefinition|RoleDefinition|CapabilityDefinition
     *
     * @param  Collection<int, T>  $definitions
     * @return array<string, Collection<int, T>>
     */
    private function groupBySourceClass(Collection $definitions): array
    {
        $grouped = [];

        foreach ($definitions as $definition) {
            $className = class_basename($definition->sourceClass);
            if (! isset($grouped[$className])) {
                $grouped[$className] = collect();
            }
            $grouped[$className]->push($definition);
        }

        // Sort by class name for deterministic output
        ksort($grouped);

        return $grouped;
    }

    /**
     * Generate a const object from items.
     *
     * @param  array<string, string>  $items
     */
    private function generateConstObject(string $groupName, array $items): string
    {
        $lines = ["export const {$groupName} = {"];

        foreach ($items as $constName => $value) {
            $lines[] = "  {$constName}: \"{$value}\",";
        }

        $lines[] = '} as const;';

        return implode("\n", $lines);
    }

    /**
     * Generate a union type from group names.
     *
     * @param  array<string>  $groupNames
     */
    private function generateUnionType(string $typeName, array $groupNames): string
    {
        if (count($groupNames) === 1) {
            $groupName = $groupNames[0];

            return "export type {$typeName} = typeof {$groupName}[keyof typeof {$groupName}];";
        }

        $unions = array_map(
            fn (string $groupName) => "typeof {$groupName}[keyof typeof {$groupName}]",
            $groupNames
        );

        return "export type {$typeName} = ".implode(' | ', $unions).';';
    }
}
