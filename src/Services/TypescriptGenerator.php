<?php

declare(strict_types=1);

namespace OffloadProject\Mandate\Services;

use Illuminate\Support\Facades\File;
use OffloadProject\Mandate\Attributes\PermissionsSet;
use OffloadProject\Mandate\Attributes\RoleSet;
use OffloadProject\Mandate\Contracts\FeatureRegistryContract;
use OffloadProject\Mandate\Contracts\RoleRegistryContract;
use ReflectionClass;
use ReflectionClassConstant;

/**
 * Generates TypeScript files from permission, role, and feature class definitions.
 */
final class TypescriptGenerator
{
    public function __construct(
        private readonly FeatureRegistryContract $featureRegistry,
        private readonly RoleRegistryContract $roleRegistry,
    ) {}

    /**
     * Generate TypeScript content from discovered permission, role, and feature classes.
     */
    public function generate(): string
    {
        $output = "// This file is auto-generated by mandate:typescript. Do not edit manually.\n\n";

        // Generate permissions
        $permissionClasses = $this->discoverClasses(
            'mandate.permission_directories',
            PermissionsSet::class
        );

        foreach ($permissionClasses as $className => $constants) {
            $output .= $this->generateExport($className, $constants);
        }

        // Generate roles
        $roleClasses = $this->discoverClasses(
            'mandate.role_directories',
            RoleSet::class
        );

        foreach ($roleClasses as $className => $constants) {
            $output .= $this->generateExport($className, $constants);
        }

        // Generate features
        $features = $this->discoverFeatures();

        if (! empty($features)) {
            $output .= $this->generateExport('Features', $features);
        }

        // Generate role hierarchy
        $hierarchy = $this->generateRoleHierarchy();
        if (! empty($hierarchy)) {
            $output .= $hierarchy;
        }

        return $output;
    }

    /**
     * Generate role hierarchy TypeScript export.
     */
    private function generateRoleHierarchy(): string
    {
        $roles = $this->roleRegistry->all();
        $hierarchyData = [];

        foreach ($roles as $role) {
            if (! empty($role->inheritsFrom) || ! empty($role->inheritedPermissions)) {
                $hierarchyData[$role->name] = [
                    'inheritsFrom' => $role->inheritsFrom,
                    'permissions' => $role->permissions,
                    'inheritedPermissions' => $role->inheritedPermissions,
                ];
            }
        }

        if (empty($hierarchyData)) {
            return '';
        }

        $lines = ['export const RoleHierarchy = {'];

        foreach ($hierarchyData as $roleName => $data) {
            $inheritsFrom = json_encode($data['inheritsFrom']);
            $permissions = json_encode($data['permissions']);
            $inheritedPermissions = json_encode($data['inheritedPermissions']);

            $lines[] = "  \"{$this->escapeString($roleName)}\": {";
            $lines[] = "    inheritsFrom: {$inheritsFrom},";
            $lines[] = "    permissions: {$permissions},";
            $lines[] = "    inheritedPermissions: {$inheritedPermissions},";
            $lines[] = '  },';
        }

        $lines[] = '} as const;';
        $lines[] = '';
        $lines[] = 'export type RoleWithHierarchy = keyof typeof RoleHierarchy;';
        $lines[] = '';

        return implode("\n", $lines);
    }

    /**
     * Discover features and extract their names.
     *
     * @return array<string, string> Map of class short name to feature name
     */
    private function discoverFeatures(): array
    {
        $features = [];

        foreach ($this->featureRegistry->all() as $feature) {
            $shortName = class_basename($feature->class);
            $features[$shortName] = $feature->name;
        }

        return $features;
    }

    /**
     * Discover classes from configured directories and extract their constants.
     *
     * @param  class-string  $attributeClass
     * @return array<string, array<string, string>> Map of class name to constants
     */
    private function discoverClasses(string $configKey, string $attributeClass): array
    {
        $directories = config($configKey, []);
        $classes = [];

        foreach ($directories as $directory => $namespace) {
            if (! is_dir($directory)) {
                continue;
            }

            foreach (File::allFiles($directory) as $file) {
                $class = $this->resolveClassName($file->getPathname(), $directory, $namespace);

                if (! class_exists($class)) {
                    continue;
                }

                $reflection = new ReflectionClass($class);

                if (empty($reflection->getAttributes($attributeClass))) {
                    continue;
                }

                $shortName = $reflection->getShortName();
                $constants = $this->extractConstants($reflection);

                if (! empty($constants)) {
                    $classes[$shortName] = $constants;
                }
            }
        }

        return $classes;
    }

    /**
     * Extract public string constants from a class.
     *
     * @param  ReflectionClass<object>  $reflection
     * @return array<string, string> Map of constant name to value
     */
    private function extractConstants(ReflectionClass $reflection): array
    {
        $constants = [];

        foreach ($reflection->getReflectionConstants(ReflectionClassConstant::IS_PUBLIC) as $constant) {
            $value = $constant->getValue();

            if (is_string($value)) {
                $constants[$constant->getName()] = $value;
            }
        }

        return $constants;
    }

    /**
     * Generate a TypeScript export statement for a class.
     *
     * @param  array<string, string>  $constants
     */
    private function generateExport(string $className, array $constants): string
    {
        $lines = ["export const {$className} = {"];

        foreach ($constants as $name => $value) {
            $escapedValue = $this->escapeString($value);
            $lines[] = "  {$name}: \"{$escapedValue}\",";
        }

        $lines[] = '} as const;';
        $lines[] = '';

        return implode("\n", $lines);
    }

    /**
     * Escape a string for use in TypeScript.
     */
    private function escapeString(string $value): string
    {
        return str_replace(
            ['\\', '"', "\n", "\r", "\t"],
            ['\\\\', '\\"', '\\n', '\\r', '\\t'],
            $value
        );
    }

    /**
     * Resolve a fully qualified class name from a file path.
     */
    private function resolveClassName(string $filePath, string $directory, string $namespace): string
    {
        $relativePath = str_replace($directory, '', $filePath);
        $relativePath = mb_ltrim($relativePath, DIRECTORY_SEPARATOR);
        $relativePath = str_replace('.php', '', $relativePath);
        $relativePath = str_replace(DIRECTORY_SEPARATOR, '\\', $relativePath);

        return $namespace.'\\'.$relativePath;
    }
}
